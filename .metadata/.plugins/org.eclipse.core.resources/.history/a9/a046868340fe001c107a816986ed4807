package api.FinalProject.starter.service;

import java.util.ArrayList;
import java.util.List;
import org.springframework.stereotype.Service;

import api.FinalProject.starter.resources.containers.BigContainer;
import api.FinalProject.starter.resources.containers.SmallContainer;
import api.FinalProject.starter.resources.items.Item;

@Service
public class OrderService {
	private List<Item> order = new ArrayList<Item>();
	private BigContainer biggie = new BigContainer(0);
	private SmallContainer smalls = new SmallContainer(0);
	
	public List<Item> getOrder(){
		return order;
	}
	
	public Item getItemByName(String itemName) {
		return order.stream().filter(t -> t.getItemName().equals(itemName)).findFirst().get();
	}
	
	public void addItem(Item i) {
		order.add(i);
	}
	
	public double orderVolume(String<Item> order) {
		double totalVolume = 0;
		for(Object value : order.values()) {
			totalVolume += (((item) value).getVolume() * ((item) value).getAmount());
		}
		return totalVolume;
	}
	
	public void bestShippingMethod(List<Item> order, BigContainer biggie, SmallContainer smalls) {
		double localVolume = orderVolume(order);
		double localWeight = orderWeight(order);
		double smallVolume = smalls.getContainerVolume();
		double bigVolume = biggie.getContainerVolume();
		//the counter variable stores the amount of objects from the order that have already been packed into a container
		int counter = 0;
		//when the packed items equals the items of the order, the program stops packing items
		while(counter != order.size()){
			double temp = 0;
			if(localVolume > smallVolume) {
				//every time a big container is added, the object's amount is updated
				biggie.setAmount(biggie.getAmount() + 1);
				//this loop goes through the order looking for objects that are not still in a container
				for(String key : order.keySet()) {
					Object value = order.get(key);
					while(!(((item) value).getAmount() == 0) && (temp + ((item) value).getVolume()) < bigVolume && !(((item) value).getAmount() == 0)) {
						temp += ((item) value).getVolume();
						((item) value).setAmount(((item) value).getAmount() - 1);
						localVolume -= ((item) value).getVolume();
						localWeight -= ((item) value).getWeight();
					}
					if(((item) value).getAmount() == 0) {
						counter += 1;
						continue;
					}
				}
			}
			else {
				//if there's the need, there will be only one small container
				smalls.setAmount(smalls.getAmount() + 1);
				smalls.setWeight(localWeight);
				//same than the loop for the big container
				for(String key : order.keySet()) {
					Object value = order.get(key);
					while(!(((item) value).getAmount() == 0) && !(((item) value).getAmount() == 0)) {
						temp += ((item) value).getVolume();
						((item) value).setAmount(((item) value).getAmount() - 1);
						localVolume -= ((item) value).getVolume();
					}
					if(((item) value).getAmount() == 0) {
						counter += 1;
						continue;
					}
				}
			}
		}
		double cost = shippingCost(biggie, smalls);
		System.out.println("Big containers used: " + biggie.getAmount());
		System.out.println("Small containers used: " + smalls.getAmount());
		System.out.println("Shipping cost: " + cost);
	}

	
	
}
